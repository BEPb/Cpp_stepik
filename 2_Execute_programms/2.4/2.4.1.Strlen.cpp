// task 2.4.1.
unsigned strlen(const char *str)  //Функция принимает указатель на строку в качестве аргумента
{
    unsigned len = 0; // функция инициализирует переменную с именем `len` нулем
    while (*str != '\0')  // Цикл продолжается до тех пор, пока не будет достигнут нулевой символ завершения (`\0`)
    {
        str++;
        len++;
    }
    return len;
}
/* Это простая реализация функции strlen в C++, которая вычисляет длину заданной строки путем перебора каждого символа,
пока не будет достигнут нулевой символ завершения ('\0').

Функция `strlen` — это стандартная библиотечная функция языка C++, которая используется для вычисления длины заданной
строки. Однако в этом случае у нас есть собственная реализация функции `strlen`.

Функция принимает указатель на строку в качестве аргумента, что указывается параметром `const char *str`. Ключевое слово
 `const` используется для указания того, что функция не будет изменять содержимое строки, на которую указывает `str`.
 Это хорошая практика, поскольку она помогает предотвратить случайное изменение входной строки.

Затем функция инициализирует переменную с именем `len` нулем. Эта переменная будет использоваться для отслеживания длины
 строки.

Затем функция входит в цикл while. Цикл продолжается до тех пор, пока не будет достигнут нулевой символ завершения
(`\0`) в конце строки. Нулевой символ завершения используется для обозначения конца строки в C.

Для каждой итерации цикла функция увеличивает указатель `str`, чтобы он указывал на следующий символ в строке, и
увеличивает переменную `len` на единицу. Это продолжается до тех пор, пока не встретится нулевой символ завершения.

Как только достигается нулевой символ завершения, функция выходит из цикла и возвращает длину строки в переменной `len`.

В целом, эта реализация функции `strlen` проста и эффективна, так как она перебирает каждый символ в строке только один
раз. Однако он предполагает, что входная строка завершается нулем, что может быть не всегда так. Кроме того, он не
выполняет никаких проверок ошибок, таких как проверка нулевого входного указателя.
*/